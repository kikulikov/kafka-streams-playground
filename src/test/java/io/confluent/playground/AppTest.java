/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.confluent.playground;

import kafka.streams.compound.ByteMethods;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.serialization.*;
import org.apache.kafka.streams.*;
import org.apache.kafka.streams.kstream.*;
import org.apache.kafka.streams.processor.AbstractProcessor;
import org.apache.kafka.streams.processor.ProcessorContext;
import org.apache.kafka.streams.state.KeyValueStore;
import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;
import org.apache.kafka.streams.state.Stores;
import org.apache.kafka.streams.test.ConsumerRecordFactory;
import org.junit.jupiter.api.Test;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Properties;
import java.util.UUID;

@Deprecated
public class AppTest {

    // 1. Item (Item ID, Name)
    // 2. Customer (Customer ID, Name)
    // 3. Order (Customer ID, Item ID, Timestamp, Amount)
    // .. Order (Order ID, Customer ID, Item ID, Timestamp, Amount)
    //
    // As a retailer,
    // I want to know which items the customer ordered
    // so that I could group items in packages.
    //
    // As a retailer,
    // I want to know which items are most popular today
    // so I could keep a supply of items available for sale.

    static class OrdersProcessor<K, V> extends AbstractProcessor<K, V> {

        private KeyValueStore<byte[], String> ordersStore;
        private String stateStoreName;

        public OrdersProcessor(String stateStoreName) {
            this.stateStoreName = stateStoreName;
        }

        @Override
        public void init(ProcessorContext context) {
            super.init(context);
            this.ordersStore = (KeyValueStore<byte[], String>) context.getStateStore(stateStoreName);
        }

        @Override
        public void process(K key, V value) {
            // TODO Pair.of() -> Serialized
            ordersStore.put(ByteMethods.ByteKey.toBinaryKey(key.hashCode(), value.hashCode()).get(), key.toString() + value.toString());
        }
    }

    static class OrdersTransformer implements Transformer<UUID, Long, KeyValue<UUID, Long>> {

        private ProcessorContext context;
        private KeyValueStore<byte[], String> ordersStore;

        @Override
        public void init(ProcessorContext context) {
            this.context = context;
            this.ordersStore = (KeyValueStore<byte[], String>) context.getStateStore("the-orders-store");
        }

        @Override
        public KeyValue<UUID, Long> transform(UUID customerId, Long itemId) {
            System.out.println("Transform >>> >>> " + customerId + ", " + itemId);
            // TODO ordersStore.put(key, value);
            ordersStore.put(ByteMethods.ByteKey.toBinaryKey(customerId.hashCode(), itemId.hashCode()).get(), ""); // Tuple (val1, val2)
            return new KeyValue<>(customerId, itemId); // key-value
        }

        @Override
        public void close() {
            ordersStore.close();
        }
    }

    @Test
    public void testBytes() {
        System.out.println(Arrays.toString(ByteMethods.ByteKey.toBinaryKey("buenos dias".hashCode(), "buenas noches".hashCode()).get()));
        System.out.println(Arrays.toString(ByteMethods.lowerRangeHigherByte("buenos dias").get()));
        System.out.println(Arrays.toString(ByteMethods.upperRangeHigherByte("buenas noches").get()));
        System.out.println(Arrays.toString(ByteBuffer.allocate(4).putInt(10205).array()));
        System.out.println(Arrays.toString(ByteBuffer.allocate(4).putInt(10206).array()));
        System.out.println(Arrays.toString(ByteBuffer.allocate(4).putInt(10207).array()));
    }

    @Test
    public void testTransformTopology() {

        System.out.println();

        final Serde<String> stringSerde = Serdes.String();
        final Serde<Long> longSerde = Serdes.Long();
        final Serde<UUID> uuidSerde = Serdes.UUID();

        // ==============
        // Build topology
        // ==============
        final StreamsBuilder builder = new StreamsBuilder();
        final KTable<Long, String> itemsTable = builder.table("retail-items", Consumed.with(longSerde, stringSerde));
        final KTable<UUID, String> customersTable = builder.table("retail-customers", Consumed.with(uuidSerde, stringSerde));
        final KStream<UUID, Long> ordersStream = builder.stream("retail-orders", Consumed.with(uuidSerde, longSerde));

        itemsTable.toStream().peek((key, value) -> System.out.println("Item: " + key + ", " + value));
        customersTable.toStream().peek((key, value) -> System.out.println("Customer: " + key + ", " + value));
        ordersStream.peek((key, value) -> System.out.println("Order: " + key + ", " + value));

        final String ordersStoreName = "the-orders-store";

        builder.addStateStore(Stores.keyValueStoreBuilder(
                Stores.persistentKeyValueStore(ordersStoreName), uuidSerde, longSerde));

        ordersStream.join(customersTable, (orderVal, customerVal) -> new Pair(orderVal, customerVal));

        ordersStream.join(customersTable, (orderVal, customerVal) -> 1L)
                .peek((key, value) -> System.out.println("Joined >>> " + key + ", " + value))
                .transform(OrdersTransformer::new, ordersStoreName);

        final Topology topology = builder.build();
        System.out.println(topology.describe());

        // TODO compound key for timestamp
        // time window aggregations

        // =============
        // Test topology
        // =============
        final Properties config = new Properties();
        config.put(StreamsConfig.APPLICATION_ID_CONFIG, "test");
        config.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "dummy:1234");

        final TopologyTestDriver testDriver = new TopologyTestDriver(topology, config);

        final ConsumerRecordFactory<Long, String> itemsFactory =
                new ConsumerRecordFactory<>("retail-items", new LongSerializer(), new StringSerializer());

        final ConsumerRecordFactory<UUID, String> customersFactory =
                new ConsumerRecordFactory<>("retail-customers", new UUIDSerializer(), new StringSerializer());

        final ConsumerRecordFactory<UUID, Long> ordersFactory =
                new ConsumerRecordFactory<>("retail-orders", new UUIDSerializer(), new LongSerializer());

        testDriver.pipeInput(itemsFactory.create(42L, "Bunch of Monkeys"));
        testDriver.pipeInput(itemsFactory.create(128L, "Pod of Whales"));
        testDriver.pipeInput(itemsFactory.create(8L, "Handful of Crickets"));

        final UUID uuid1 = UUID.randomUUID();
        final UUID uuid2 = UUID.randomUUID();

        testDriver.pipeInput(customersFactory.create(uuid1, "Franz Kafka"));
        testDriver.pipeInput(customersFactory.create(uuid2, "Donald Trump"));

        testDriver.pipeInput(ordersFactory.create(uuid2, 8L));
        testDriver.pipeInput(ordersFactory.create(uuid1, 42L));
        testDriver.pipeInput(ordersFactory.create(uuid1, 128L));

        testDriver.getAllStateStores().forEach((s, stateStore) -> System.out.println(s + ", " + stateStore));

//        ReadOnlyKeyValueStore<String, Long> keyValueStore =
//                streams.store("CountsKeyValueStore", QueryableStoreTypes.keyValueStore());
        ReadOnlyKeyValueStore<String, Long> keyValueStore = testDriver.getKeyValueStore(ordersStoreName);

        // keyValueStore.get(BytesKey.toBinaryKey(uuid2.toString(), "8"));
        // TODO get(String) vs get(Bytes)

//        System.out.println(testDriver.readOutput("result-topic", new UUIDDeserializer(), new LongDeserializer()));
//        System.out.println(testDriver.readOutput("result-topic", new UUIDDeserializer(), new LongDeserializer()));
//        System.out.println(testDriver.readOutput("result-topic", new UUIDDeserializer(), new LongDeserializer()));

        // TODO KeyValueStore store = testDriver.getKeyValueStore("store-name");

        // OutputVerifier.compareKeyValue(outputRecord, "key", 42L);
    }

    @Test
    public void testBasicTopology() {

        System.out.println();

        final Serde<String> stringSerde = Serdes.String();
        final Serde<Long> longSerde = Serdes.Long();
        final Serde<UUID> uuidSerde = Serdes.UUID();

        // ==============
        // Build topology
        // ==============
        final StreamsBuilder builder = new StreamsBuilder();
        final KTable<Long, String> itemsTable = builder.table("retail-items", Consumed.with(longSerde, stringSerde));
        final KTable<UUID, String> customersTable = builder.table("retail-customers", Consumed.with(uuidSerde, stringSerde));
        final KStream<UUID, Long> ordersStream = builder.stream("retail-orders", Consumed.with(uuidSerde, longSerde));

        itemsTable.toStream().peek((key, value) -> System.out.println("Item: " + key + ", " + value));
        customersTable.toStream().peek((key, value) -> System.out.println("Customer: " + key + ", " + value));
        ordersStream.peek((key, value) -> System.out.println("Order: " + key + ", " + value));

        ordersStream.join(customersTable, (orderVal, customerVal) -> 1L)
                .peek((key, value) -> System.out.println("Joined >>> " + key + ", " + value))
                .groupByKey(Grouped.with(uuidSerde, longSerde))
                .reduce(Long::sum)
                .toStream()
                .peek((key, value) -> System.out.println("Reduced >>> " + key + ", " + value))
                .to("result-topic", Produced.with(uuidSerde, longSerde));

        // ordersStream.join(customersTable, (value1, customer) -> customer).to("result-topic");

        // builder.stream("input-topic").filter((key, value) -> true).to("output-topic");
        final Topology topology = builder.build();

        System.out.println(topology.describe());

        // =============
        // Test topology
        // =============
        final Properties config = new Properties();
        config.put(StreamsConfig.APPLICATION_ID_CONFIG, "test");
        config.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "dummy:1234");

        final TopologyTestDriver testDriver = new TopologyTestDriver(topology, config);

        final ConsumerRecordFactory<Long, String> itemsFactory =
                new ConsumerRecordFactory<>("retail-items", new LongSerializer(), new StringSerializer());

        final ConsumerRecordFactory<UUID, String> customersFactory =
                new ConsumerRecordFactory<>("retail-customers", new UUIDSerializer(), new StringSerializer());

        final ConsumerRecordFactory<UUID, Long> ordersFactory =
                new ConsumerRecordFactory<>("retail-orders", new UUIDSerializer(), new LongSerializer());

        testDriver.pipeInput(itemsFactory.create(42L, "Bunch of Monkeys"));
        testDriver.pipeInput(itemsFactory.create(128L, "Pod of Whales"));
        testDriver.pipeInput(itemsFactory.create(8L, "Handful of Crickets"));

        final UUID uuid1 = UUID.randomUUID();
        final UUID uuid2 = UUID.randomUUID();

        testDriver.pipeInput(customersFactory.create(uuid1, "Franz Kafka"));
        testDriver.pipeInput(customersFactory.create(uuid2, "Donald Trump"));

        testDriver.pipeInput(ordersFactory.create(uuid2, 8L));
        testDriver.pipeInput(ordersFactory.create(uuid1, 42L));
        testDriver.pipeInput(ordersFactory.create(uuid1, 128L));

        testDriver.getAllStateStores().forEach((s, stateStore) -> System.out.println(s + ", " + stateStore));

        final ProducerRecord<UUID, Long> outputRecord1 =
                testDriver.readOutput("result-topic", new UUIDDeserializer(), new LongDeserializer());

        System.out.println(outputRecord1);

        final ProducerRecord<UUID, Long> outputRecord2 =
                testDriver.readOutput("result-topic", new UUIDDeserializer(), new LongDeserializer());

        System.out.println(outputRecord2);

        // TODO KeyValueStore store = testDriver.getKeyValueStore("store-name");

        // OutputVerifier.compareKeyValue(outputRecord, "key", 42L);
    }

    // TODO testDriver.advanceWallClockTime(20L); // punctuation ???

    public static class Unit<A> {

        public final A a;

        public Unit(A a) {
            this.a = a;
        }

        public static <AA> Unit<AA> of(AA aa) {
            return new Unit<>(aa);
        }
    }

    public static class Pair<A, B> {

        public final A a;
        public final B b;

        public Pair(A a, B b) {
            this.a = a;
            this.b = b;
        }

        public static <AA, BB> Pair<AA, BB> of(AA aa, BB bb) {
            return new Pair<>(aa, bb);
        }
    }

    public static class Triplet<A, B, C> {

        public final A a;
        public final B b;
        public final C c;

        public Triplet(A a, B b, C c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        public static <AA, BB, CC> Triplet<AA, BB, CC> of(AA aa, BB bb, CC cc) {
            return new Triplet<>(aa, bb, cc);
        }
    }
}
